<script type="text/javascript">
    (function ()
    {
        let treeList;
        let candidateNodesCount = 0;
        let flows = [];
        let flowMap = {};

        function onEditPrepare(node, targetTypes)
        {
            if (!node.links)
                node.links = [];

            const activeSubflow = RED.nodes.subflow(node.z);

            treeList = $("<div>")
                .css({ width: "100%", height: "100%" })
                .appendTo(".node-input-link-row")
                .treeList({ autoSelect: false })
                .on("treelistitemmouseover", function (e, item)
                {
                    if (item.node)
                    {
                        item.node.highlighted = true;
                        item.node.dirty = true;
                        RED.view.redraw();
                    }
                })
                .on("treelistitemmouseout", function (e, item)
                {
                    if (item.node)
                    {
                        item.node.highlighted = false;
                        item.node.dirty = true;
                        RED.view.redraw();
                    }
                });

            flows = [];
            flowMap = {};

            if (activeSubflow)
            {
                flowMap[activeSubflow.id] = {
                    id: activeSubflow.id,
                    class: "red-ui-palette-header",
                    label: "Subflow : " + (activeSubflow.name || activeSubflow.id),
                    expanded: true,
                    children: []
                };
                flows.push(flowMap[activeSubflow.id]);
            }
            else
            {
                RED.nodes.eachWorkspace(function (ws)
                {
                    if (!ws.disabled)
                    {
                        flowMap[ws.id] = {
                            id: ws.id,
                            class: "red-ui-palette-header",
                            label: (ws.label || ws.id) + (node.z === ws.id ? " *" : ""),
                            expanded: true,
                            children: []
                        };
                        flows.push(flowMap[ws.id]);
                    }
                });
            }

            setTimeout(function ()
            {
                treeList.treeList("show", node.z);
            }, 100);
        }

        function initTreeList(node, targetTypes)
        {
            candidateNodesCount = 0;
            for (const key in flowMap)
            {
                flowMap[key].children = [];
            }

            let candidateNodes = [];

            targetTypes.forEach(function (targetType)
            {
                candidateNodes = candidateNodes.concat(RED.nodes.filterNodes({ type: targetType }));
            });

            candidateNodes.forEach(function (n)
            {
                if (flowMap[n.z])
                {
                    const isChecked = (node.links.indexOf(n.id) !== -1) || (n.links || []).indexOf(node.id) !== -1;
                    if (isChecked)
                    {
                        flowMap[n.z].children.push({
                            id: n.id,
                            node: n,
                            label: n.name || n.id,
                            selected: false,
                            checkbox: false,
                            radio: false
                        });
                        candidateNodesCount++;
                    }
                }
            });

            for (const key in flowMap)
            {
                flowMap[key].children.sort((a, b) => a.label.localeCompare(b.label));
            }

            const flowsFiltered = flows.filter(function (f) { return f.children.length > 0 });
            treeList.treeList("empty");
            treeList.treeList("data", flowsFiltered);
        }

        function resizeNodeList()
        {
            var rows = $("#dialog-form>div:not(.node-input-link-row)");
            var height = $("#dialog-form").height();
            for (var i = 0; i < rows.length; i++)
            {
                height -= $(rows[i]).outerHeight(true);
            }
            var editorRow = $("#dialog-form>div.node-input-link-row");
            height -= (parseInt(editorRow.css("marginTop")) + parseInt(editorRow.css("marginBottom")));
            $(".node-input-link-row").css("height", height + "px");
        }

        RED.nodes.registerType("smart_shutter-complex-control", {
            category: "Smart Nodes",
            paletteLabel: "Shutter complex control",
            color: "#C882FF",
            defaults: {
                name: { value: "" },
                max_time: { value: 60 },
                revert_time_ms: { value: 100 },
                alarm_action: { value: 'NOTHING' }, // NOTHING | UP | DOWN
                links: { value: [], type: "smart_central-control[]" }
            },
            inputs: 1,
            outputs: 3,
            outputLabels: ["Up", "Down", "Status Position"],
            icon: "font-awesome/fa-align-justify",
            label: function ()
            {
                return this.name || "Shutter complex control";
            },
            oneditprepare: function ()
            {
                let node = this;

                onEditPrepare(this, ["smart_central-control"]);
                initTreeList(node, ["smart_central-control"]);

                $("#node-input-max_time").spinner({
                    min: 1,
                    change: function (event, ui)
                    {
                        var value = parseInt(this.value);
                        value = isNaN(value) ? 0 : value;
                        value = Math.max(value, parseInt($(this).attr("aria-valuemin")));
                        // value = Math.min(value, parseInt($(this).attr("aria-valuemax")));
                        if (value !== this.value)
                            $(this).spinner("value", value);
                    }
                });

                $("#node-input-revert_time_ms").spinner({
                    min: 1,
                    change: function (event, ui)
                    {
                        var value = parseInt(this.value);
                        value = isNaN(value) ? 0 : value;
                        value = Math.max(value, parseInt($(this).attr("aria-valuemin")));
                        // value = Math.min(value, parseInt($(this).attr("aria-valuemax")));
                        if (value !== this.value)
                            $(this).spinner("value", value);
                    }
                });

                $("#node-input-alarm_action").typedInput({
                    types: [
                        {
                            default: "NOTHING",
                            options: [
                                { value: "NOTHING", label: "Keine Aktion" },
                                { value: "UP", label: "Hoch / Öffnen" },
                                { value: "DOWN", label: "Runter / Schließen" }
                            ],
                        },
                    ],
                });
            },
            onadd: function ()
            {
                this.links = [];
            },
            oneditresize: resizeNodeList
        });
    })();
</script>

<script type="text/html" data-template-name="smart_shutter-complex-control">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name" />
    </div>
    <div class="form-row">
        <label for="node-input-max_time"><i class="fa fa-clock-o"></i> Zeit [s]</label>
        <input id="node-input-max_time" placeholder="Zeit für eine komplette Fahrt [s]" />
    </div>
    <div class="form-row">
        <label for="node-input-revert_time_ms"><i class="fa fa-clock-o"></i> Pause Wechsel [ms]</label>
        <input id="node-input-revert_time_ms" placeholder="Pause zwischen Richtungswechsel [ms]" />
    </div>
    <div class="form-row">
        <label for="node-input-alarm_action"><i class="fa fa-exclamation-triangle"></i> Alarm Aktion</label>
        <input id="node-input-alarm_action"/>
    </div>
    <span><i class="fa fa-link"></i> Dieser Baustein wird von folgenden Zentralbausteinen gesteuert:</span>
    <div class="form-row node-input-link-row node-input-link-rows"></div>
</script>

<script type="text/html" data-help-name="smart_shutter-complex-control">
    <p>
        <b>Hinweis:</b> Diese Node wurde entwickelt, falls die KNX Rollladensteuerung nicht verwendet werden kann um man gezwungen ist 2 separate Ausgänge für Auf und Ab zu verwenden.
        Es ist dabei sehr zu empfehlen, dass die Ausgänge sich gegenseitig verriegeln um ein gleichzeitiges Ansteuern zu verhindern. Für etwaige Schäden am Rollladen ist jeder selbst verantwortlich.
    </p>
    <p>
        <b>Hinweis:</b> Smart Nodes verwenden Topics im Format <code>name#nummer</code>, damit können verschiedene Smart Nodes mit dem gleichen Topic angesteuert werden.<br/>
        Diese Node verwendet nur den Teil <code>name</code>. <code>#</code> und <code>nummer</code> sind dabei optional.
    </p>
    <p>
        Diese Node steuert Rollladen oder Jalousien.
        Es gibt 3 Ausgänge die angesteuert werden können:
        <ol>
            <li><b>Auf:</b> <code>msg.payload = true;</code> startet den Rollladen um nach oben zu fahren und <code>msg.payload = false;</code> stoppt diesen wieder.</li>
            <li><b>Ab:</b> <code>msg.payload = true;</code> startet den Rollladen um nach unten zu fahren und <code>msg.payload = false;</code> stoppt diesen wieder.</li>
            <li><b>Status Position:</b> <code>msg.payload = 42;</code>Gibt den aktuellen Status der Rollladen aus. 0 = offen, 100 = geschlossen.</li>
        </ol>
        Die Ausgänge sind den jeweiligen KNX Gruppenadressen zuzuordnen.
    </p>
    <p>
        Diese Node erwartet folgende Topics als Eingang:<br/>
        <table>
            <thead>
                <tr>
                    <th>Topic</th>
                    <th>Beschreibung</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>up_stop</code></td>
                    <td>Sendet abwechselnd einen Stop- und einen Hochfahrbefehl.</td>
                </tr>
                <tr>
                    <td><code>down</code></td>
                    <td>Sendet einen Runterfahrbefehl, falls der Rollladen nicht bereits nach unten fährt. Ggf. wird vorher noch ein Stop-Befehl gesendet und die eingestellte Zeit gewartet.</td>
                </tr>
                <tr>
                    <td><code>down_stop</code></td>
                    <td>Sendet abwechselnd einen Stop- und einen Runterfahrbefehl.</td>
                </tr>
                <tr>
                    <td><code>up_down</code></td>
                    <td>Nimmt einen Befehl von Home Assistant entgegen und leitet die entsprechende Aktion ein.</td>
                </tr>
                <tr>
                    <td><code>stop</code></td>
                    <td>Sendet einen Stopbefehl.</td>
                </tr>
                <tr>
                    <td><code>position</code></td>
                    <td>Sendet einen Positionsbefehl. <code>msg.payload</code> sollte ein Wert zwischen 0 (offen) und 100 (geschlossen) haben.</td>
                </tr>
                <tr>
                    <td><code>alarm</code></td>
                    <td>Setzt den aktuellen Alarmzustand.</td>
                </tr>
                <tr>
                    <td><code>toggle</code> (default)</td>
                    <td>Schaltet den Rollladen abwechselnd auf hoch, stop, runter, stop.</td>
                </tr>
            </tbody>
        </table>
    </p>
    <p>
        Diese Node verwaltet keine Laufzeit für den Rollladen selbst. Diese muss über ETS für den Ausgang konfiguriert werden.
        Es ist jedoch möglich, den Rollladen nach einer definierten Zeit automatisch abzuschalten.
        Beispiel: <code>msg = { "topic": "up", "time_on": 5000 }</code> oder <code>msg = { "topic": "up", "time_on": "5s" }</code><br/>
        Diese Nachricht lässt den Rollladen für 5000 Millisekunden / 5 Sekunden nach oben fahren. Sollte es sich um eine Jalousie halten, werden die Lamellen entsprechend gedreht.
        Als Einheit für die Zeit können folgende Werte verwendet werden:
        <table>
            <thead>
                <tr>
                    <th>Einheit</th>
                    <th>Beschreibung</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>ms</code> (default)</td>
                    <td>Millisekunden</td>
                </tr>
                <tr>
                    <td><code>s</code> oder <code>sec</code></td>
                    <td>Sekunden</td>
                </tr>
                <tr>
                    <td><code>m</code> oder <code>min</code></td>
                    <td>Mintun.</td>
                </tr>
                <tr>
                    <td><code>h</code></td>
                    <td>Stunden</td>
                </tr>
            </tbody>
        </table>
    </p>
    <p>
        Die Angabe einer Zeit funktioniert nicht mit dem topic <b>position</b>.
    </p>
</script>